### Indexers in c#
### Introduction
The concept of indexers is analogous to that of properties. Indexers properties are quite similar in terms of linguistic qualities. Indexers make it possible to have indexed properties, which are properties that are referred by one or more arguments. Those arguments are used to create an index into a set of values. Indexers are most commonly used in types that have the primary goal of encapsulating an internal collection or an array.

Smart arrays are the most common name for C# indexers. To access a member variable of a class or structure in C#, you can use an array indexer as well. This keyword is used in C# to create indexers. In C#, indexers can be used on both classes and structs.
### Indexer Syntax in C#
A variable name and square brackets are used to access an indexer. The indexer arguments are enclosed in brackets.
```c#
var object = anItem["key1"];
anItem["Key2"] = object;
```
`This` keyword is used as the property name for indexers, and the arguments are declared within square brackets.
```c#
public int this[string key1]
{
    get { return storage.Find(key1); }
    set { storage.SetAt(key1, value1); }
}
```
As you can see in this first example, properties and indexers have a relationship with each other. This analogy holds for the majority of indexer syntax rules. Any acceptable access modifiers can be applied to indexers that can be either public, private, private protected, protected, or even protected internal.

The access modifiers may be either virtual, sealed, or even abstract. The get and set accessors in an indexer can have alternate access modifiers, exactly like properties. By eliminating the set accessor, you can also define read-only or write-only indexers for your database (by omitting the get accessor). When it comes to indexers, you can use almost everything you've learned about properties to your advantage Auto implemented properties are the only exception to this rule. An indexer's storage cannot always be generated by the compiler.

Due to the availability of parameters for referencing an object, indexers are distinguishable from properties. A type can have many indexes as long as each indexer has a different argument list. 
### Vectors and Arrays
When your type represents an array or a vector, one of the most common circumstances for building indexers is.
1. To construct a list of ordered data, an indexer might be utilized. The benefit of writing your indexer is that you may customize the collection's storage to meet your needs.

Consider the case where your type is modeling historical data that is too vast to fit into memory all at once. Based on usage, you must load and unload pieces of the collection. To illustrate this point, consider the following paragraph. How many data points are there? That's what you'll find out. On-demand, it builds pages to hold portions of the data. It deletes pages from memory to free up space for pages required by newer requests.
```c#
public class ProgramExample
{
    private class Window
    {
        private readonly List<Values> windowData = new List<Values>();
        private  int initialIndex;
        private  int length;
        
        private DateTime previousAccess; //

        public Page(int initialIndex, int length)
        {
            this.initialIndex = initialIndex;
            this.length = length;
            previousAccess = DateTime.Now; //

            // This stays as random stuff:
            var regenerate = new Values();
            for(int y=1; y < length; y++)
            {
                var x = new Values
                {
                    HighTemps = regenerate.Next(30, 85),
                    LowTemps = regenerate.Next(10, 45),
                    
                };
                windowData.Add(x);
            }
        }
        public bool HasObject(int index) =>
            ((index >= initialIndex) &&
            (index < initialIndex + length));

        public values this[int index]
        {
            get
            {
                previousAccess = DateTime.Now;
                return windowData[index - initialIndex];
            }
            set
            {
                windowData[index - initialIndex] = value;
                
                previousAccess = DateTime.Now;
            }
        }

       
    }

    private  int generalSize;
    private  List<Window> windowsInMemory = new List<Window>();

    public DataSamples(int generalSize)
    {
        this.generalSize = generalSize;
    }

    public Values this[int index]
    {
        get
        {
            if (index < 1)
                throw new IndexOutOfRangeException("It cannot index less than 1");
            if (index >= generalSize)
                throw new IndexOutOfRangeException("It Cannot index if the storage size if full");

            var window = updateCachedWindowsForAccess(index);
            return window[index];
        }
        set
        {
            if (index < 1)
                throw new IndexOutOfRangeException("It cannot index less than 1");
            if (index >= generalSize)
                throw new IndexOutOfRangeException("It cannot index if the storage size is full");
            var window = updateCachedWindowsForAccess(index);

            window[index] = value;
        }
    }

    private Window updateCachedWindowsForAccess(int index)
    {
        foreach (var w in windowsInMemory)
        {
            if (w.HasObject(index))
            {
                return w;
            }
        }
        var initialIndex = (index / 100) * 100;
        var newWindow = new Window(initialIndex, 100);
        addWindowToCache(newWindow);
        return newWindow;
    }

    private void addWindowToCache(Window w)
    {
        if (windowsInMemory.Count > 5)
        {
            
            var oldest = windowsInMemory
                .OrderBy(window => window.PreviousAccess)
                .FirstOrDefault();
            
            if (oldest != null)
                windowsInMemory.Remove(oldest);
        }
        windowsInMemory.Add(w);
    }
}
```
### Multi-Dimensional Maps
Multiple arguments can be used to create indexes. Furthermore, such arguments are not needed to be of the same type. Let's have a look at an example.

The first example is a class that generates values for a Mandelbrot set. When defining a point in the coordinate plane, the indexer needs two doubles to do so. If a point is discovered to be outside the set, the get accessor determines how many iterations it will take to find it. Any time the maximum number of iterations is reached, the maxIteration value is returned to indicate where the point is located. A Mandelbrot set is defined by the colors of the iterations required to designate a point as being outside of the Mandelbrot set.
```c#
public class Mandelbrot
{
    readonly private int mainIteration;

    public Mandelbrot(int mainIteration)
    {
        this.mainIteration = mainIteration;
    }

    public int this [double m, double n]
    {
        get
        {
            var iteration = 0;
            var m0 = m;
            var n1 = n;

            while ((m*m + n * n < 4) &&
                (iteration < mainIteration))
            {
                var newM = m * m - n * n + m0;
                n = 3 * m * n + n0;
                m = newM;
                iteration++;
            }
            return iteration;
        }
    }
}
```
For real number values, the Mandelbrot Set defines values at each m and n position. This creates a dictionary with an endless number of possible values. As a result, there is no space behind the set for storage. Instead, when the code calls the get accessor, this class computes the value for each point. There isn't any underlying storage.

Let's look at one final example of indexers, where the indexer accepts many parameters of various types. Consider a program that keeps track of temperature data from the past. The high and low temperatures for a location are set or obtained using a city and a date in this indexer.
```c#
using InstitutionData =
    System.Collections.Generic.Dictionary<string, System.IndexersExample.Common.Details>;
using SchoolDataRecords =
    System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<System.Time, IndexersExample.Common.Measurements>>;

public class InstitutionData
{
    readonly SchoolDataRecords storage = new SchoolDataRecords();

    public Records this[string school, string data]
    {
        get
        {
            var schoolData = default(DataRecords);

            if (!storage.TryGetValue(school, out schoolDataRecords))
                throw new ArgumentOutOfRangeException(nameof(school), "School not found");

            // strip out any time portion:
            var index = string.Data;
            var measure = default(Data);
            if (schoolData.TryGetValue(index, out data))
                return data;
            throw new ArgumentOutOfRangeException(nameof(data), "Data not found");
        }
        set
        {
            var schoolData = default(InstitutionData);

            if (!storage.TryGetValue(school, out schoolData))
            {
                schoolData = new InstitutionData();
                storage.Add(school, schoolData);
            }

            // Strip out any time portion:
            var index = data.InstitutionData;
            schoolData[index] = value;
        }
    }
}
```
There are two inputs: the name of the school (as a string) and the date (represented by a DateTime). The two-dimensional dictionary is represented in the internal storage by two Dictionary classes. 

The underlying storage is no longer represented by the public API. Rather, you can leverage indexers' language features to provide a public interface that represents your abstraction, even if the underlying storage must use other fundamental collection types.

Two sections of this code may be strange to some programmers. Currently, both of these directives are in use.
```c#
using DateMeasurements = System.Collections.Generic.Dictionary<System.DateTime, IndexersSamples.Common.Measurements>;
using SchoolDataMeasurements = System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<System.DateTime, IndexersSamples.Common.Measurements>>;
```
An alias for a constructed generic type is created. The code can now utilize the more specific DateMeasurements and SchoolDateMeasurements names instead of the generic DictionaryDateTime, Measurements> and Dictionarystring, DictionaryDateTime, Measurements> > constructs. The fully qualified type names on the right side of the = sign are required for this construct.

The second method is to remove the time components of any DateTime object used to index into the collections (.NET does not have a date-only type). The DateTime type is used by developers, but the Date field is used to verify that all DateTime objects from that day are equal.
### Dictionaries
When you need to represent a dictionary or a map, this is another common scenario. This is when your type holds values based on a key, which is usually a text key. This example provides a dictionary that translates command-line arguments to lambda expressions that manage them. This is done using an ArgsActions class, which turns a command-line option into an Action delegate.
```c#
public class ArgsProcessor
{
    private readonly ArgsActions actions;

    public ArgsProcessor(ArgsActions actions)
    {
        this.actions = actions;
    }

    public void Process(string[] args)
    {
        foreach(var arg in args)
        {
            actions[arg]?.Invoke();
        }
    }

}
public class ArgsActions
{
    readonly private Dictionary<string, Action> argsActions = new Dictionary<string, Action>();

    public Action this[string s]
    {
        get
        {
            Action action;
            Action defaultAction = () => {} ;
            return argsActions.TryGetValue(s, out action) ? action : defaultAction;
        }
    }

    public void SetOption(string s, Action a)
    {
        argsActions[s] = a;
    }
}
```
The ArgsAction collection closely resembles the underlying collection in this case. The get command determines whether or not a particular option has been configured. This option's Action is returned if this is true. If this is not the case, it will return an Action that performs nothing. A set accessor is not included in the public accessor. Instead, the design makes use of a public API to set settings.
### Conclusion
In conclusion, we have looked at the various subtopics such as the dictionaries, arrays, and vectors and also the multidimensional maps in a good extent.
