### Introduction
The `Java Virtual Machine (JVM)` is the Java program that executes the main function. When you install **JRE**, you'll also get JVM (Java Runtime Environment). Machine code is generated by a compiler in other programming languages. When it comes time to compile Java code, it does so using the Java Virtual Machine. It allows Java apps to run.
### Types of virtual machines
1. **System-based virtual machines (SVM)**: As a replacement for physical computers, SVMs were developed. A host computer runs them and uses its hardware resources.

2. **Application-based virtual machines (AVM)**: It lets a single process run as an application on the host machine without involving any hardware. Process-based virtual machines are another name for them. To this group belongs the JVM, which we'll discuss in this article.

AVM, on the other hand, allows a single process to run as an application on the host machine without engaging any hardware components. Process-based virtual machines are another name for them. To this group belongs the JVM, which we'll discuss in this session.
There are created a .java file, .class files with the identical names as those in the java file. This .class file breaks down the JVM into numerous phases that describe how it works.
1. ClassLoader
2. JVM Memory 
3. Execution Engine 
4. Java Native Interface (JNI)
5. Native Method Libraries
### Class loader subsystem
There are three of the class loaders:
- Application class loader
- Extension class loader
- Bootstrap class loader

As one of the phases of JVM, it mainly consists of three activities which are listed below:
1. **Loading**:

 ".class" files are loaded into the method area by the ClassLoader, which generates the binary data corresponding to the class file. The method area of each ".class" file in JVM contains the following information.
- Class name and its immediate parent class.
- ".class" files can be classified as Class or Interface.
- There is a lot of detail on the modifier, variables, and method.

As soon as the ".class" file is loaded, the JVM constructs a Class object to represent it in the heap memory. It should be noted that this object belongs to the Java.lang package's Class class.Class objects allow the programmer to extract class-level information such as the class name, its parent, methods, and variables. getClass() of the Object class can be used as a way to retrieve this reference to the object.
```java
import java.lang.reflect.Field;
import java.lang.reflect.Method;
public class Test {
    public static void main(String[] args)
    {
        pupil p1 = new pupil();
        Class cl1 = p1.getClass();
        System.out.println(cl1.getName());
        Method m[] = cl1.getDeclaredMethods();
        for (Method method : m)
            System.out.println(method.getName());
        Field f[] = cl1.getDeclaredFields();
        for (Field field : f)
            System.out.println(field.getName());
    }
}
class pupil {
    private String name;
    private int roll_No;
  
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getRoll_no() { return roll_No; }
    public void setRoll_no(int roll_no)
    {
        this.roll_No = roll_no;
    }
}
```
**Output**
```
pupil
getName
setName
getRoll_no
setRoll_no
name
roll_No
```
>Note that each ".class" file loaded creates only one object of the class.

2. **Linking**:

Executes three operations, including:

- **Preparation**:It allocates memory and initializes it to default settings for class variables.
- **Verification**: You may be sure that a file is correct as long as it has been correctly formatted and created by a valid compiler. The java.lang run-time exception is thrown when the verification fails. VerifyError. In this case, the component ByteCodeVerifier is responsible. Thereafter, the class file is ready to be compiled.
- **Resolution**: As the name suggests, it involves substituting direct references for the types of symbolic references. Searching for the referenced entity in the method area is how it is accomplished.

>Delegation-Hierarchy principle is used by JVM to load classes. Loading requests are delegated to extension classloaders, which in turn delegate requests to bootstrapping classloaders by system classloaders. For any other requests that are not routed through an extension class loader, they are routed through the system class loader if it is found in the boot-strap path. As a last resort, java.lang. ClassNotFoundException run-time exceptions occur when the system class loader fails to load the class specified by the system class loader.

### JVM Memory 
The `Runtime Data Area` is another name for the memory area. In total, it's broken down into five sub-areas.

1. **Method area**: Static variables are also saved in the method area together with class information such as class name, parent class name, methods etc.
2. **Heap area**: In the heap area, all objects' information is saved. There is also a Heap Area for each Java Virtual Machine. It's also a resource that's shared.
3. **Stack area**: Every block of this stack is termed an activation record/stack frame, and it stores method calls in each of the blocks therein. There is a frame for each local variable. A thread's run-time stack will be destroyed by JVM after it has terminated. Because of this, it is not an accessible resource to the general public.
4. **PC registers**: Store the address of the thread's current instruction. Each thread has its PC Registers, as you might expect.
5. **Native method area**: Every thread has its native stack. Stores information about a native method's parameters.
### Execution Engine
To run a ".class" file, you need an execution engine. Reading byte-code from a file, using data from various memory areas, then executing instructions. The execution engine consists of three components named below:

1. **Interpreter**: Essentially, the interpreter takes bytecode and translates it to machine code. Interpreters may be faster at running one line of bytecode than they are at executing the full code. Also, a fresh interpretation must be provided each time the same method is invoked.
2. **JIT Compiler (Just In Time compiler)**: To execute byte code, the interpreter is the first choice of the execution engine. The JIT compiler will be used instead of the execution engine detects that a method is repeated. It consists of the following;
-  Intermediate Code Generator.
- Code Optimizer.
- Target Code Generator.
- Profiler.
3. **Garbage Collector(GC)**: As a background process, the garbage collector can eliminate unreferenced objects and free up space in the heap.
### Java Native Interface (JNI)
Interacting with Native Method Libraries and providing native libraries (C, C++) for execution. Because of it, the JVM can call and be called by C/C++ libraries that are hardware-specific.
### Native Method Libraries
It's a set of native libraries (C, C++) required by the Execution Engine.
### Conclusion
Although a virtual machine is not based on reality, it will replicate the surroundings to make you feel as if it were.  When it comes time to compile Java code, it does so using the Java Virtual Machine. It allows Java apps to run.
